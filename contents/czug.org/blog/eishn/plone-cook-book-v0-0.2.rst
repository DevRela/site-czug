---
created: 2007-01-08 14:13:35
creator: eishn
description: "本书主要面向 ArcheTypes/Plone 开发者。读者不一定必须是中高级 Plone 开发人员, 但是必须要掌握一定的 ArcheTypes\
  \ 基础知识。\r\n\r\n如果您尚未有 ArcheTypes 的开发经历, 那么直接阅读本文档会有一定的困难。但这并不妨碍您通读本文档、迅速掌握其中各个知识点,\
  \ 并能在实际开发中迅速索引到本文档的相关章节。\r\n\r\n请时刻握好您的工具, Google 以及 Plone.org 右上角的 ZCatalog 接口。事实上本文档不会面面俱到,\
  \ 因为它总是假定您是一名出色的黑客。\r\n\r\n-寻找源码, 追随源码, 模仿源码, 洞察源码, 成为别人的范例源码。"
title: Plone Cook Book v0.0.2
---
<h1 style="text-align: center;"><a href="http://eishn.plonespace.net/docs/plone-cook-book/plone-cook-book">Plone Cook Book</a></h1> <p style="text-align: center;">2006 年 5 日, Version 0.0.2</p> <p style="text-align: center;"><a href="http://cqit_jsj.blog.163.com">魏中华</a> <a href="http://eishn.blog.163.com">沈崴</a> 庄上林</p>  <br /><br /><br /><br /><br /><br /> <div><h2>其他版本</h2> <ul><li><a href="http://eishn.plonespace.net/docs/plone-cook-book/plone-cook-book">在线浏览</a></li><li><a href="http://eishn.plonespace.net/docs/plone-cook-book/plone-cook-book.pdf">PDF 版本下载</a></li><li><a href="http://eishn.plonespace.net/docs/plone-cook-book/plone-cook-book.html">HTML 版本下载</a><br /></li> </ul></div> <p><br /></p> <p><br /></p> <p><br /></p>    <h2>适应人群 &amp; 注意事项</h2>  <p>本书主要面向 ArcheTypes/Plone 开发者。读者不一定必须是中高级 Plone 开发人员, 但是必须要掌握一定的 ArcheTypes 基础知识。</p> <p>如果您尚未有 ArcheTypes 的开发经历, 那么直接阅读本文档会有一定的困难。但这并不妨碍您通读本文档、迅速掌握其中各个知识点, 并能在实际开发中迅速索引到本文档的相关章节。</p> <p>请时刻握好您的工具, Google 以及 Plone.org 右上角的 ZCatalog 接口。事实上本文档不会面面俱到, 因为它总是假定您是一名出色的黑客。</p> <pre style="text-align: center;">寻找源码, 追随源码, 模仿源码, 洞察源码, 成为别人的范例源码。</pre>  <p><br /></p> <p><br /></p> <p><br /></p>    <h2>ATField &amp; ATWidget 本纪</h2>  <p><br /></p>  <h3>身世</h3>  <ul> <li>ATField 源码文件 <i>Products.Archetypes.Field.py</i></li> <li>ATWidget 源码文件 <i>Products.Archetypes.Widget.py</i></li> <li>你可以在 Plone 的官方站点上找到 <a href="http://plone.org/products/by-category/widgets">更多的第三方 Field 以及 Widget</a>。</li> <li>你必须熟读 Plone.org 上 <a href="http://plone.org/documentation/manual/archetypes-developer-manual"> 关于 Field 以及 Widget 的文档</a> (<a href="http://plone.org/documentation/manual/archetypes-developer-manual/fields">Field/Widget Reference</a>)。</li> <li>ATField 和 ATWidget 是 ArcheTypes 的钥匙和灵魂。</li> </ul>  <p><br /></p>  <h3>ATField <b>常用属性</b></h3>  <ul> <li>required</li> <li>default</li> <li>searchable</li> <li>accessor, 取值函数。   <ul>  <li>如果没有设置该属性, ArcheTypes 会自动生成一个默认函数。</li>  <li>通常默认的命名规则是 "get" + "字段名(首字母大写)"。</li>  <li>如果恰好字段是元数据, 那么默认取值函数是 "字段名(首字母大写)", 比如 "Title"。</li>  <li>可以在 ZPT 或者 Python Script 中通过 here/getXXX (ZPT) 或者 context.getXXX (Script) 调用。</li>  </ul> </li> <li>mutator, 设值函数。请参考 accessor, 不同的是设值函数的默认名称永远是 "set" + "字段名(首字母大写)"。</li> <li>validators, 验证器。   <ul>  <li>Plone 已经提供了 isEmail、isURL、isInt 等多种验证器。具体请参见 <a href="http://plone.org/products/archetypes/documentation/old/quickref/?searchterm=validator">Plone.org 上的相关文档</a>。</li>  <li>请注意, 黑客使用 ArcheTypes 是为了避免将时间浪费在无聊的事情上, 本文档认为默认的验证器已经基本够用, 如果您发现自己总是在痛苦地编写 Validator 以适应应用, 那么无非是两种可能, 您可能搞错了, 或者您的应用搞错了。或许您需要的是一个带自定义验证的 Plone 问卷产品, 而第三方开发者早已为您准备好了。</li>  </ul> </li> <li>index, 索引类型。FieldIndex、KeywordIndex 或者 TextIndex。</li> <li>vocabulary, 可选项。您需要下载几个带下拉框的范例来理解这个字段。</li> <li>widget</li> </ul>  <p><br /></p>  <h3>ATField 关键技巧</h3> <ul> <li><b>对象标题总是和 Container 标题一样?</b>   <p>这是 Plone 的一个 Bug, 解决办法是自定义 "title" 字段 (Field) 的 accessor 和mutator。</p> </li> <li><b>当一个字段的 Widget 为 RichWidget 时, 请设置该 Field 的 default_output_type 属性的值, 如 "text/html"。否则无法使用 Plone 的编辑器 (比如 Kupu) 进行编辑。</b></li> <li><b>中文全文索引</b>   <p>Plone 默认不带有中文全文索引。请首先安装润普公司开放的 ZopeChinaPak 和 CJKSplitter。</p>  <p>最糟糕的解决方案 (如果您的产品已经不幸进入生产系统, 这时的补救方法) 是, 手工在 ZMI - portal_catalog 中删除原有索引, 然后添加一个支持中日韩全文索引的 ZCTextIndex 索引。毫无疑问, 您需要请尽快阅读 <a href="http://zopen.cn/products/open/CJKSplitter/">润普公司的官方说明</a>。</p>  <p>在您的项目正式开发 (事情变糟糕) 之前阅读<a href="../../../plone/howto/archetypeszhongdeneirongsuoyindeshezhishiyong">《Archetypes 中的内容索引的设置使用》</a>是个好主意。</p>  <p><a href="http://www.czug.org">CZUG 社区</a> 当然有机会让 TextIndex 在开发时对中文全文索引透明, 为此也确有过争论。但是最后他们的决定是继续保持 Plone 在国际化上的平滑性。知道这点, 也许会让您心里暂时好过些。</p> </li> <li><b>FieldIndex:schema 的使用</b>   <p>在利用 portal_catalog.searchResults 进行搜索时, 它返回一堆代表搜索结果的 brain 对象, 它们是真实对象的缩写版本 (在 ZCatalog 中实现)。</p>  <pre>得到查询结果: <i>brains = portal_catalog.searchResults(...)</i></pre>  <p>调用 brain 的 getObject() 方法可以得到真正的目标对象。通过 brain 你可以访问到该对象的元数据集 (metadata), 而对 brain 进行 getObject() 之后, 你可以访问该对象的所有属性。</p>  <pre>得到真正的结果对象: <i>obj = brain.getObject()</i></pre>  <p>如果在您的应用中, 需要访问元数据之外的属性, brain 就不够用了, 那么你需要对搜索结果进行 getObject() 操作。不幸的是 getObject() 取得的完整版结果对象过于庞大, 在搜索结果数巨大的情况下, 您的内存将迅速报销。</p>  <p>如果把字段的 Index 类型设置为 FieldIndex:schema, 则可以直接通过 brain 对象来获取该字段的值。</p>  <p>Field:schema 做了一件很简单的事情, 它将该字段像元数据一样保存在 ZCatalog 的索引中。因此, 你可以在 brain 里面直接获取到该字段。</p> </li> <li><b>ReferenceField</b>   <p>该字段实际上是一个指向其他对象的指针, 用 get 方法所获取的字段值, 是其所指向的对象。</p>  <p>我们经常会忘记 ArcheTypes 中还有这么一个好用的工具, 实在是不应该。</p> </li> </ul>  <p><br /></p>  <h3>ATWidget 关键技巧<br /></h3>  <ul> <li>Widget 的主要属性有 label、description 以及 visible 等。</li> <li>可以设置 "visible" 属性来让字段不可见, 或者不可更改, 如:<br />  <pre>visible = {"view": None, "edit": None}</pre> </li> <li>在使用 SelectionWidget 时, 可以设置 Field 的 vocabulary 作为其选项。</li> </ul>  <p><br /></p> <p><br /></p> <p><br /></p>    <h2>ATContentType 本纪</h2>  <p><br /></p>  <h3>身世</h3>  <ul> <li>Plone 预定义了 8 种 Base Class, 见 Products.Archetypes.public 中的 BaseClass 部分。</li> <li>其中出场率最高的是 BaseContent、BaseFolder、BaseBTreeFolder, 以 Folder 结尾的, 都带有 Folder (文件夹) 的特性。</li> <li>不用理会对 BaseBTreeFolder 性能问题的扯淡, 它能够装下几千万对象 (保守估计)。但是如果你少写了 BTree 这两个字, 您的文件夹可能只能放下几千个对象 (乐观估计)。</li> </ul>  <p><br /></p>  <h3>ATContentType 关键技巧</h3>  <ul> <li>如果自定义 Folder 类型 (ContentType) 需要使用到 CMFContentPanels (润普公司开放的界面布局产品), 该 ContentType 必须同时继承 BrowserDefaultMixin。请阅读 <a href="http://zopen.cn/products/open/CMFContentPanels/">CMFContentPanels 的具体说明</a>, 非常地简单。</li> <li>如果一个文件夹下面需要放相当多的文件 (大于 1000), 请从 BaseBTreeFolder 继承, 但不要忘记您是工作在对象数据库下, 所以一个目录下请尽量不要存放太多的对象。</li> <li>忘记关系数据库在性能上超过对象数据库 (以及网状数据库) 的谣言。洞察您的应用, 区分复杂的逻辑数据 (树型结构) 和简单的平面数据, 分别存放在对象数据库和关系数据库下, 您将同时得到最高的开发效率和执行效率。</li> </ul>  <p><br /></p>  <h3>ATContentType 常见属性 (Attributes of ATContentType)</h3>  <ul> <li>meta_type、portal_type、content_icon、schema、allow_discussion、global_allow、all_content_types、actions、security</li> <li>如果不想让您的产品变的无法控制, 或者仅仅是因为黑客不想了解太多 ArcheTypes 细节的时候, 请给 meta_type 和 portal_type 赋上一个相同的值。</li> </ul>  <p><br /></p>  <h3>和属性相关的关键技巧</h3>  <ul> <li><b>archetype_name</b> 属性。设置该 ContentType 的 title。</li> <li><b>_at_rename_after_creation</b> 属性。   <ul>  <li>对象创建后, 系统会根据对象的 title 来改变对象的 id。</li>  <li>对于中文, 如果安装了 ZopeChinaPak, id 将自动变成 title 的中文拼音。</li>  </ul> </li> <li><b>在 action 中, 重载 id 为 "view" 的视图, 可以改变默认视图</b>。</li> <li><b>设置 action 的 conditions 属性, 可以让不同权限的用户看到不同的 action 标签</b>。比如:<br />  <pre>'condition': 'python: object.portal_membership.getAuthenticatedMember().has_role("Manager", here)'</pre> </li> <li><b>去除 "共享"、"属性" 标签</b><br />  <pre><b>#在 ContentType 中加入以下内容:</b> <b>class</b> MyContentType(...):<br />    <b>def</b> modify_fti(fti):<br />        # hide unnecessary tabs (usability enhancement)<br />        <b>for</b> a <b>in</b> fti['action']:<br />            <b>if</b> a['id'] <b>in</b> ['metadata', 'sharing']:<br />                a['visible'] = 0<br />        <b>return</b> fti</pre> </li> <li>遗憾的是目前尚没有找到更好的方法来去除 "文件夹内容" 标签。可以仿照一个叫做 <a href="http://plone.org/products/poi">Poi</a> 的第三方产品来做, 但会导致添加菜单的内容混乱。</li> </ul>  <p><br /></p>  <h3>ATContentType 的常用方法 (Methods of ATContentType)</h3>  <ul> <li><b>def initializeArchetype(self, *args, **kw)</b>, 对象创建时, 将会调用该函数, 这是给开发者提供的对象初始化接口。该接口已经淘汰, 也许你会遇到使用该接口的一些旧的第三方产品, 但是在通常情况下, 请使用 at_post_create_script(self) 接口代替。   <pre><b># 下面是通常的写法, 这里以 BaseFolder 为例</b> <b>class</b> MyContentType(BaseFolder):<br />    <b>def</b> initializeArchetype(self, *args, **kw):<br />        BaseFolder.initializeArchetype(self, *args, **kw)<br />        <b># ... 我的代码</b></pre> </li> <li><b>def at_post_create_script(self)</b>, ATContentType 基类提供的一个 Hook (钩子), 在对象创建时会调用该函数。</li> <li><b>def at_post_edit_script(self)</b>, 与 at_post_create_script(self) 不同的是这个钩子是在对象被修改 (点击保存) 的时候调用的。</li> <li><b>def SearchableText(self)</b>, 对象在搜索中的描述<br />  <pre><b># <a href="../../../plone/tutorial/fenbieyongarchetypeshecmffangshikaifachanpin">SearchableText 示范</a>, 作者张炳凯</b><br /><b>def</b> SearchableText(self):    <br />""" Return the information for indexing"""<br />    <b>return</b> "%s %s %s" % (self.Title(),<br />                         self.Description(),<br />                         self._cookedText )</pre></li> </ul>  <p><br /></p> <p><br /></p> <p><br /></p>    <h2>Security (Plone Permission) 世家</h2>  <p><br /></p>  <h3>查看权限</h3>  <ul> <li><b>View</b>, 在页面上显示对象, View 是必须的</li> <li><b>Search in catalog</b>, 事实上这也是一个重要的查看权限, 只是我们将它通常保持在默认状态。请勿随意设置。</li> <li><b>List folder content</b>, 顾名思义, 列出文件夹对象的权限。</li> <li><b>Access content information</b>, 在页面上显示对象, View 是必须的。同时这个权限控制着所有对对象的操作。</li> </ul>  <p><br /></p>  <h3>写权限 (增加、修改)</h3>  <ul> <li><b>Delete Object</b></li> <li><b>Copy and Move</b></li> <li><b>Add portal content</b></li> <li><b>Modify portal content</b></li> </ul>  <p><br /></p>  <h3>其他权限</h3>  <ul> <li><b>Reply to item</b>, 评注。</li> <li><b>Add portal member</b>, 可以用来禁止注册功能。</li> </ul>  <p><br /></p>  <h3>关键技巧</h3>  <ul> <li>请注意, 在 Plone 的默认配置下, 用户可以匿名查看站点上的资料。</li> <li>请注意, 在 Plone 的默认配置下, 用户可以自由注册 (有 Add portal member 权限)。</li> <li>Plone 会默认添加一种名为 <i><b>Authenticated</b></i> 的角色。这种角色很容易造成权限配置的混乱, 建议禁止该角色。</li> <li><b>设置对象的默认访问权限</b><br />  <pre>security = ClassSecurityInfo()<br />security.declareObjectProtected('View MyContentType')<br />security.setPermissionDefault('View MyContentType', ('Manager', 'Owner', 'Member'))</pre> </li> <li><b>自动创建 (本地) 角色</b> (context._addRole 方法)<br />  <pre>for role in ['MyRole1', 'MyRole2']:<br />    self._addRole(role)</pre> </li> <li><b>控制对象方法的访问权限</b>, 基本上在范例产品中, 类似 <b>security.declarePublic('MyFunc')</b>、<b>security.declareProtected(permissions.View, 'MyFunc')</b> 这种写法随处可见。但是繁复的权限控制, 通常是由糟糕并且自相矛盾的需求, 或者控制狂引起的, 我们需要时刻保持清醒以避免一切失控。尽管人类历史上从未出现过如此强大而易配置的权限系统。<br /> </li> </ul>  <p><br /></p> <p><br /></p> <p><br /></p>    <h2>Workflow 世家</h2>  <p><br /></p>  <h3>创建工作流</h3>  <ul> <li>安装产品 <b><a href="http://plone.org/products/dcworkflowdump">DCWorkflowDump</a></b>, 进入 ZMI - portal_workflow 创建自己的工作流。点击 "Dump" 标签, 程序将自动生成该工作流的源码。</li> <li>我们都爱 DCWorkflowDump。</li> </ul>  <p><br /></p>  <h3>protal_workflow</h3>  <ul> <li><b>State</b> 标签页</li> <li><b>Transitions</b> 标签页, 其中 Expression 为 TALES 表达式。<br />  <pre>python: here.getUserName() == user.getUserName()</pre> </li> <li><b>Scripts</b>, 你可以让对象在状态改变时执行一个 Python Script。请参考润由 <a href="http://www.czug.org">CZUG</a> 合著的<a href="http://zopen.cn/training/doc/plone-freebook/">《Plone 资料汇编》</a>第八章, 其中 "通常的任务与例子" 一节可以满足您居家旅行的大部分需要。</li> </ul>  <p><br /></p>  <h3>安装工作流</h3>  <pre># <a href="http://plone.org/documentation/tutorial/understanding-permissions/workflow-in-products/">Using permissions and workflow in your custom products</a> <br /># Author, <a href="http://plone.org/author/optilude">Martin Aspeli</a> <br /><b>def</b> install(self):<br />    <b>from</b> Products.MyProduct.Extensions <b>import</b> MyWorkflow<br />    wf_tool = getToolByName(self, 'portal_workflow')<br />    <b>if</b> not 'my_workflow' <b>in</b> wf_tool.objectIds():<br />        wf_tool.manage_addWorkflow('my_workflow (My custom workflow)',<br />                                   'my_workflow')<br />    wf_tool.updateRoleMappings()<br />    wf_tool.setChainForPortalTypes(pt_names=['MyType'],<br />                                   chain='my_workflow')</pre>  <p><br /></p>  <h3>关键技巧</h3>  <ul> <li><b>获取当前对象的 state</b>  <ul>  <li>对于 brain 类型的对象 (比如搜索结果), 可以直接使用 brain.<b>review_state</b> 获得</li>  <li>对于常规类型, 可以使用 getInfoFor 方法取得<br />  <pre>wf_tool = getToolByName(self, 'portal_workflow')<br />st = wf_tool.getInfoFor(self, 'review_state')</pre>  </li>  </ul> </li> <li>获取 State 的 Title<br />  <pre>wf_tool = getToolByName(self, 'portal_workflow')<br />title = wf_tool.getTitleForStateOnType(st, self.portal_type)</pre> </li> <li>获取当前对象的工作流的所有状态<br />  <pre>def getAllStatesChainForCT(self, content_portal_type):<br />    """ Get all the state about the portal_type """<br />    wftool = getToolByName(self, 'portal_workflow')<br />    chain  = wftool.getChainForPortalType(content_portal_type)<br />    workflow = getattr(wftool, chain[0])<br />    states   = getattr(workflow, 'states')<br />    state_list = []<br />    for id, state in states.items():<br />        state_list.append((id, state.title))<br />    return state_list</pre> </li> <li><b>执行 Transition (状态跃迁)</b><br />  <pre>wf_tool = getToolByName(self, 'portal_workflow')<br />wf_tool.doActionFor(self, 'transition_name')</pre> </li> </ul>  <p><br /></p> <p><br /></p> <p><br /></p>     <h2>Python Scripts 列传</h2><p><br /></p><h3>Request 对象</h3><p>用户提交的数据会以字典形式存储在 Request 对象中。</p><ul><li>在 ZPT 中, 该对象的名字是 request</li><li>在 Python Script 中, 该对象为 context.REQUEST<br /></li></ul>  <p><br /></p>  <h3>Response 对象</h3>  <p>RESPONSE = context.REQUEST.RESPONSE</p>  <ul> <li>处理完毕后, 如果需要 redirect 到另一个页面, 则 Response 就可以派上用场。<br />  <pre>RESPONSE.redirect(URL)</pre> </li> <li>使用 Plone 系统的消息功能<br />  <pre>RESPONSE.redirect(context.absolute_url() + '?portal_status_message=发生错误，请与管理员联系')</pre> </li> <li>设置 Cookie<br />  <pre>RESPONSE.setCookie('变量名', 变量值, expires='Web, 19 Feb 2020 14:28:00 GMT')</pre> </li> </ul>  <p><br /></p> <p><br /></p> <p><br /></p>    <h2>评注·列传</h2>  <p><br /></p>  <h3>添加评注</h3> <pre>dtool = getToolByName(context, 'portal_discussion')<br />tb = dtool.getDiscussionFor(context)<br />id = tb.createReply(title='TITLE', text='TEXT', creator='CREATOR')<br />reply = tb.getReply(id)</pre>  <h3>获取对象所有评注</h3> <pre>def getRs(obj, replies, counter):<br />    rs = pd.getDiscussionFor(obj).getReplies()<br />    # 对评注按修改日期排序<br />    rs = container.sort_modified_ascending(rs)<br />    for r in rs:<br />        replies.append({'depth':counter, 'object':r})<br />        getRs(r, replies, counter=counter + 1)<br />replies = []<br />pd = container.portal_discussion<br />from Products.CMFDefault.DiscussionTool import DiscussionNotAllowed<br />try:<br />    pd.getDiscussionFor(page_obj)<br />except DiscussionNotAllowed:<br />    # We tried to get discussions for an object that has not only<br />    # discussions turned off but also no discussion container.<br />    return []<br />getRs(page_obj, replies, 0)<br />return replies</pre>  <p><br /></p> <p><br /></p> <p><br /></p>    <h2>角色·列传</h2>  <p><br /></p>  <pre>pm = getToolByName(self, 'portal_memebership')</pre>  <p><br /></p>  <h3>创建角色</h3> <pre>self._addRole('ROLE')</pre>  <p><br /></p>  <h3>获取角色列表</h3> <pre>pm.getCandidateLocalRoles(context)</pre>  <p><br /></p>  <h3>分配角色</h3> <pre>pm.setLocalRoles(obj=self, member_ids=[...], member_role='Contributor')</pre>  <p><br /></p>  <h3>删除用户角色</h3> <pre>pm.deleteLocalRoles(obj=self, member_ids=[...])</pre>   <p><br /></p> <p><br /></p> <p><br /></p>    <h2>港台音乐</h2>  <h3>手工 (强制) 提交事务</h3>  <pre><b>import</b> transaction<br />transaction.commit()</pre>  <p><br /></p>  <h3>获取当前登录用户</h3>  <ul> <li>ZPT, user.getUserName()</li> <li>ArcheTypes, portal.portal_membership.getAuthenticatedMember()</li> </ul>  <p><br /></p>  <h3>在 Skin 上显示 HTML 格式的文本</h3>  <pre>&lt;span tal:content="<b>structure</b> python: here.CookedBody(stx_level=2)"&gt;</pre>  <h3>不重启, Refesh Products</h3>  <ul> <li>在你的 Product 目录下添加一个名为 "refresh.txt" 的文件</li> <li>进入 ZMI:ZOPE-ROOT/control_panel/products/MyProduct, 在 Refresh 页面下可对 Product 进行 Refresh 操作, 也可以设置 Auto Refresh Mode 来进行定时 Refresh</li> </ul>  <p><br /></p>  <h3>获取请求的 URL</h3> <pre>context.REQUEST['URL']</pre>  <p><br /></p>  <h3>对 searchResults 的查询结果按照对象的 title 进行排序</h3> <pre>context.searchResult(sort_on = 'sortable_title', ...)</pre>  <p><br /></p>  <h3>在自定义 form 里面调用 Kupu 编辑器</h3> <pre>&lt;metal:block tal:define="<br />    editor      python: here.portal_membership.getAuthenticatedMember().wysiwyg_editor;<br />    wysiwyg     python: test(editor and (editor!='None'), editor, 'None');<br />    use_wysiwyg python: 1 "&gt;<br />    &lt;metal:block tal:define="<br />        inputname  python:'my_input';<br />        formname   python:'my_from';<br />        inputvalue python:'the content of the field';<br />        width      python:200;<br />        height     python:300;<br />        tabindex   tabindex/next; "&gt;<br />        &lt;div metal:use-macro="here/wysiwyg_support/macros/wysiwygEditorBox"&gt;<br />            The WYSIWYG code<br />        &lt;/div&gt;<br />    &lt;/metal:block&gt;<br />&lt;/metal:block&gt;</pre>